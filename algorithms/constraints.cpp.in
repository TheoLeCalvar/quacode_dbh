#include <algorithms/constraints.hh>
#include <algorithms/kernels.hh>
#include <string.h>
#include <stdio.h>
#include <assert.h>

CUDA_DEVICE bool Constraint::cmpEQ(int lhs, int rhs) {
    return (lhs == rhs);
}

CUDA_DEVICE bool Constraint::cmpNQ(int lhs, int rhs) {
    return (lhs != rhs);
}

CUDA_DEVICE bool Constraint::cmpGQ(int lhs, int rhs) {
    return (lhs > rhs);
}

CUDA_DEVICE bool Constraint::cmpGR(int lhs, int rhs) {
    return (lhs >= rhs);
}

CUDA_DEVICE bool Constraint::cmpLQ(int lhs, int rhs) {
    return (lhs < rhs);
}

CUDA_DEVICE bool Constraint::cmpLE(int lhs, int rhs) {
    return (lhs <= rhs);
}

CUDA_DEVICE Constraint::cmpFuncPtr Constraint::getCmpPtr(TComparisonType t) {
    switch (t) {
        case CMP_NQ:
            return &Constraint::cmpNQ;
        case CMP_EQ:
            return &Constraint::cmpEQ;
        case CMP_LQ:
            return &Constraint::cmpLQ;
        case CMP_LE:
            return &Constraint::cmpLE;
        case CMP_GQ:
            return &Constraint::cmpGQ;
        case CMP_GR:
            return &Constraint::cmpGR;
        default:
            assert(0);
    }
    return nullptr;
}

CUDA_HOST bool Constraint::evaluate(Constraint ** cstrs, size_t nbCstrs, const int * candidat) {
#ifdef __CUDACC__
    return evaluateCstrs(cstrs, nbCstrs, candidat);
#else
    for (size_t i = 0; i < nbCstrs; ++i) {
        if (!cstrs[i]->evaluate(candidat)) return false;
    }
    return true;
#endif
}

CUDA_DEVICE   void Constraint::describe() {
    printf("%p\tConstraint\n", this);
}

CUDA_HOST  CstrEq * CstrEq::create(size_t v0, int v2) {
#ifdef __CUDACC__
    CstrEq ** dTmp, *hTmp;
    CCR(cudaMalloc((void**)&dTmp, sizeof(CstrEq*)));
    CstrEqKernel<<<1,1>>>(dTmp, v0, v2);
    CCR(cudaGetLastError());
    CCR(cudaMemcpy(&hTmp, dTmp, sizeof(CstrTimes*), cudaMemcpyDeviceToHost));
    CCR(cudaFree(dTmp));
    return hTmp;
#else
    return new CstrEq(v0, v2);
#endif
}

CUDA_HOST CUDA_DEVICE CstrEq::CstrEq(size_t v0, int v2):
    v0(v0), v2(v2)
{}

CUDA_DEVICE bool CstrEq::evaluate(const int * c) {
    return c[v0] == c[v2];
}

CUDA_DEVICE   void CstrEq::describe() {
    printf("%p\tConstraint Equal\tv[%lu] = %d\n", this, v0, v2);
}

CUDA_DEVICE CstrBool::opFuncPtr CstrBool::getOpPtr(TOperatorType op) {
    switch (op) {
        case OP_AND:
            return &CstrBool::opAnd;
        case OP_OR:
            return &CstrBool::opOr;
        case OP_IMP:
            return &CstrBool::opImp;
        case OP_XOR:
            return &CstrBool::opXor;
        default:
            assert(0);
    }
    return nullptr;
}

CUDA_HOST   CstrBool * CstrBool::create(bool p0, size_t v0, TOperatorType op, bool p1, size_t v1, TComparisonType cmp, size_t v2) {
#ifdef __CUDACC__
    CstrBool ** dTmp, * hTmp;
    CCR(cudaMalloc((void**)&dTmp, sizeof(CstrBool*)));
    CstrBoolKernel<<<1,1>>>(dTmp, p0, v0, op, p1, v1, cmp, v2);
    CCR(cudaGetLastError());
    CCR(cudaMemcpy(&hTmp, dTmp, sizeof(CstrTimes*), cudaMemcpyDeviceToHost));
    CCR(cudaFree(dTmp));
    return hTmp;
#else
    return new CstrBool(p0, v0, CstrBool::getOpPtr(op), p1, v1, Constraint::getCmpPtr(cmp), v2);
#endif
}

CUDA_HOST CUDA_DEVICE CstrBool::CstrBool(bool p0, size_t v0, opFuncPtr op, bool p1, size_t v1, cmpFuncPtr cmp, size_t v2):
    p0(p0), v0(v0), op(op), p1(p1), v1(v1), cmp(cmp), v2(v2)
{}

CUDA_DEVICE bool CstrBool::evaluate(const int * c) {
    return cmp(op(p0, c[v0], p1, c[v1]), c[v2]);
}

CUDA_DEVICE   void CstrBool::describe() {
    printf("%p\tConstraint Bool\t%sv[%lu] OP %sv[%lu] CMP v[%lu]\n", this, (p0 ? "" : "!"), v0, (p1 ? "" : "!"), v1, v2);
}

CUDA_DEVICE bool CstrBool::opAnd(bool p0, bool v0, bool p1, bool v1) {
    return (p0 ? v0 : !v0) && (p1 ? v1 : !v1);
}

CUDA_DEVICE bool CstrBool::opOr(bool p0, bool v0, bool p1, bool v1) {
    return (p0 ? v0 : !v0) || (p1 ? v1 : !v1);
}

CUDA_DEVICE bool CstrBool::opImp(bool p0, bool v0, bool p1, bool v1) {
    return !((p0 ? v0 : !v0) && !(p1 ? v1 : !v1));
}

CUDA_DEVICE bool CstrBool::opXor(bool p0, bool v0, bool p1, bool v1) {
    return (!(p0 ? v0 : !v0) != !(p1 ? v1 : !v1));
}

CUDA_HOST   CstrPlus* CstrPlus::create(int n0, size_t v0, int n1, size_t v1, TComparisonType cmp, size_t v2) {
#ifdef __CUDACC__
    CstrPlus ** dTmp, * hTmp;
    CCR(cudaMalloc((void**)&dTmp, sizeof(CstrPlus*)));
    CstrPlusKernel<<<1,1>>>(dTmp, n0, v0, n1, v1, cmp, v2);
    CCR(cudaGetLastError());
    CCR(cudaMemcpy(&hTmp, dTmp, sizeof(CstrTimes*), cudaMemcpyDeviceToHost));
    CCR(cudaFree(dTmp));
    return hTmp;
#else
    return new CstrPlus(n0, v0, n1, v1, Constraint::getCmpPtr(cmp), v2);
#endif
}

CUDA_HOST CUDA_DEVICE CstrPlus::CstrPlus(int n0, size_t v0, int n1, size_t v1, cmpFuncPtr cmp, size_t v2):
    n0(n0), v0(v0), n1(n1), v1(v1), cmp(cmp), v2(v2)
{}

CUDA_DEVICE bool CstrPlus::evaluate(const int * c) {
    return cmp(n0 * c[v0] + n1 * c[v1], v2);
}

CUDA_DEVICE   void CstrPlus::describe() {
    printf("%p\tConstraint Plus\t%d * v[%lu] +  %d * v[%lu] CMP v[%lu]\n", this, n0, v0, n1, v1, v2);
}

CUDA_HOST   CstrTimes * CstrTimes::create(int n, size_t v0, size_t v1, TComparisonType cmp, size_t v2) {
#ifdef __CUDACC__
    CstrTimes ** dTmp, * hTmp;
    CCR(cudaMalloc((void**)&dTmp, sizeof(CstrTimes*)));
    CstrTimesKernel<<<1,1>>>(dTmp, n, v0, v1, cmp, v2);
    CCR(cudaGetLastError());
    CCR(cudaMemcpy(&hTmp, dTmp, sizeof(CstrTimes*), cudaMemcpyDeviceToHost));
    CCR(cudaFree(dTmp));
    return hTmp;
#else
    return new CstrTimes(n, v0, v1, Constraint::getCmpPtr(cmp), v2);
#endif
}


CUDA_HOST CUDA_DEVICE CstrTimes::CstrTimes(int n, size_t v0, size_t v1, cmpFuncPtr cmp, size_t v2):
    n(n), v0(v0), v1(v1), cmp(cmp), v2(v2)
{}

CUDA_DEVICE bool CstrTimes::evaluate(const int * c) {
    return cmp(n * c[v0] * c[v1], v2);
}

CUDA_DEVICE   void CstrTimes::describe() {
    printf("%p\tConstraint Times\t%d * v[%lu] * v[%lu] CMP v[%lu]\n", this, n, v0, v1, v2);
}

CUDA_HOST CstrLinear::~CstrLinear() {
//TODO: faire un vri bon destructeur
#ifndef __CUDACC__
    if (poly) {
        delete[] poly;
    }
#endif
}

CUDA_HOST   CstrLinear * CstrLinear::create(size_t * poly, size_t size, TComparisonType cmp, size_t v0) {
#ifdef __CUDACC__
    CstrLinear ** dTmp, * hTmp;
    size_t * dPoly;

    CCR(cudaMalloc((void**)&dTmp, sizeof(CstrLinear*)));
    CCR(cudaMalloc((void**)&dPoly, 2 * size * sizeof(size_t)));
    CCR(cudaMemcpy(dPoly, poly, 2 * size * sizeof(size_t), cudaMemcpyHostToDevice));
    CstrLinearKernel<<<1,1>>>(dTmp, dPoly, size, cmp, v0);
    CCR(cudaGetLastError());
    CCR(cudaMemcpy(&hTmp, dTmp, sizeof(CstrTimes*), cudaMemcpyDeviceToHost));
    CCR(cudaFree(dTmp));
    return hTmp;
#else
    return new CstrLinear(poly, size, Constraint::getCmpPtr(cmp), v0);
#endif
}

CUDA_HOST CUDA_DEVICE CstrLinear::CstrLinear(size_t * p, size_t polySize, cmpFuncPtr cmp, size_t v0):
    poly(p), polySize(polySize), cmp(cmp), v0(v0)
{
#ifndef __CUDACC__
    size_t * polyTmp = new size_t[polySize];
    memcpy(polyTmp, p, polySize * sizeof(size_t));
    poly = polyTmp;
#endif
}

CUDA_DEVICE bool CstrLinear::evaluate(const int * c) {
    int sum = 0;

    for (size_t i = 0; i < polySize; ++i) {
        sum += poly[2 * i] * c[poly[2 * i + 1]];
    }

    return cmp(sum, c[v0]);
}

CUDA_DEVICE   void CstrLinear::describe() {
    printf("%p\tConstraint Linear\t", this);
    for (size_t i = 0; i < (polySize - 1); ++i) {
        printf("%lu * v[%lu] + ", poly[2 * i], poly[(2 * i) + 1]);
    }
    printf("%lu * v[%lu] CMP v[%lu]\n", poly[(2 * polySize) - 2], poly[(2 * polySize) - 1], v0);
}
